alter table nazwa_tabeli drop check(premia<pensja);

alter table nazwa_tabeli drop constraint max_premia;

alter table nazwa_tabeli alter column cena drop check(cena>40.00);

alter table nazwa_tabeli alter column cena drop constraint cena_minimalna;

mozna i tak i tak zorbic, susuwajc mozna zrobic cascade, w tedy rekoreycjnjie się to zrobi

alter table nazwa_tabeli drop column nazwa_kolumny [cascade];

Data i czas 
date
time
now, tommorow, yesterday, today - czas to polnoc jest. 
timestamp
interval

mozna konwertowac ze stringa na daty
'string'::date
'jakisnapis'::timestamp

current_time
current_date
current_timestamp
localtime
localtimestamp

standardowo jest ISO ale jest tez SQL, i posgresa i grego
set datestyle to 'SQL, DMY';
1NF jest w tedy, kiedy wszystkie wartosci w kolumnach, ogolnie wsyzstkie wartosci to sa wartosci atomiczne, nie da sie ich podzielic (logicznie), np data to bezie watos atomiczna, pomimo ze niby ma dzien rok miesiac itp itd.
alter table nazwa_tabeli alter column nazwa_kolumny set default 2;
alter table nazwa_tabeli alter column nazwa_kolumny drop default;

typy zlozone - to takie sturktury, klasy kote maja w sobie wiecej typow danych
np 

create type complex as 	(
re real,
im real
);
mozemy uzywac jak każdego innego typu danych, czyli np w kolumnach:

create table liczby(
nazwa varchar(10),
wartosc complex),
primary key(nazwa)
);

insert into liczby values('i', (0, 1));

select * from liczby where (wartosc).im = 0;

select nazwa, (wartosc).re from liczxby;

ograniczeniem jest to, ze w zlozonych typach nie mozna dawac ograniczen jeslli chodzi o pola / atrybuty.

dalej, 
do pol musimy sie odwolwac za pomoca nawiasow, bo ianczj sql mysli ze chozi nam o tablice liczby oraz o kolumne re / im. a  dzieki nawiaosm wskazujemy, ze chozi nam o typ zlozony.

alter table nazwa_tabeli alter column cena
	type numeric(10, 2);
	
ta operacja sie poweizie,e tylkow tedy, kiedy dla kazdej wartosci bezdie mozliwe przekonwertowanie do nwego typu. mozna użyc using() aby wskazac sposb konwersji..
alter table nazwa_tabeli add column
	nazwa_kolumny typ ograniczenia - jak przy noramnym tworzeniu
alter table nazwa_tabeli add column
	cena numeric(7,2) constraint unikatowe_nazwy uniqe not null check(cena>=40);
	
alter table nazwa_tabeli drop column nazwa_kolumny cascade - cascade usuwa kaskadowo.

alter table nazwa_tabeli rename column stara_nazwa to nowa_nazwa;

alter table nazwa_tabeli rename to nowa_nazwa_tabeli;

alter table nazwa_tabeli add constraint nazwa_ogranizcenia
	ograniczenie
	
alter table nazwa_tabeli
	add foregin key(idczekoladki, idpudelka) references to zawartsoc on delete set null on update cascaade
	 jeszcze jest no action i refuse???
	 
alter table nazwa_tabeli add check(permia<pensja);
	 
alter table nazwa_tabeli alter column nazwa_kolumny set not null;
alter table nazwa_tabeli alter column nazwa_kolumny drop not null;

alter table nazwa_tabeli alter column nazwa_kolumny set default 2;
alter table nazwa_tabeli alter column nazwa_kolumny drop default;

alter table nazwa_tabeli alter column cena 
type numeric(10,2);

drop table tabela_1;
drop table if exist tabela1 refuse; restrict
drop table if exist tabela1 cascade; - kaskoadowwo, wszytkie powiazane wywali
select position('a' in 'ala');
zgodnosc referencyjna, przy kluczach obcyhc,
oresla co ma sie dziac kiedy zmieni sie kluzc glowny do ktorego sie odnosimy.

create table nazwa_tabeli(
idczekoladki not null references czekoladki on update cascade on delete set null

set null
set default
cascade
no action
restrict

alter table nazwa_tabeli add constrains nazwa_ograniczenia
	check(pensja>premia);
	
alter table nazwa_tabeli
	add foregin key(idczekoladki, idpudelka) references zawartosc on update cascade;
	
alter table nazwa_tabeli alter column cena add constarint c chceck(cena>40.00);
alter table nazwa_tabeli drop check(pensja>premia);
alter table nazwa_tabeli drop constraint nazwa_ograniczenia;
alter table nazwa_tabeli alter column nazwa_kolumny drop not null;
alter table nazwa_tabeli alter column cena drop constraint cena_minimalna;
alter table nazwa_tabeli alter column nazwa_kolumny set default 2;
alter table nazwa_tabeli alter column nazwa_kolumny drop default;

to jetst dekompozycja, jest zle rozpbiice, ktore nie zachowuje dancych - dekopmozoycja stratna, bo przy lzaczeniu natrualnym nie otrzymamy tablicy relacji poczatkowej.
nadklucz to taki zestaw atrybutow ktorego domkniecie tranzytywne da nam wszystkie wartosci z relacji,
klucz to miniamlny nadklucz, najmnczijszy z nadkluczy.

nadklucz - zbior atrybutow z ktorych wynika caly rekord, moze byc dowolnie dlugi, w ostatecznoscimoze byc calym rekordem.
drop table if exist nazwa_tabeli 
cascade,
restrict

usunecie tabeli powoduje usuniecie wyzstkich rzeczy ktore byly z tym powiazane, czyli liznikow sekwensji wyzwalaczy itp itd ? indeksy, reguly, ograniczen, jesli wartosci z tej tabli sa gdzies indziej uzywane, to powinno sie zrobic cascade, aby syfu nie bylo. 
zbior minimalny 
ma tylko zalezosci proste - po prawej stornie sa pojedyncze wartosci
nie ma zbednych zaenzosci - takich kotre wynikaja z innych 
nie ma nadmiarowosci w zaleznosichac - jesli jedna lewa storna jest pdzborem innej, i produkuja to samo, to wybieramy ta kotra jest miniesjza, ma mniej elementow, bo ona kejst wysatczajaca.
jesli jest jeden do jednego,
jesli po obou stornach jest obowiazkowe 11 11 no to laczymy w jedna tabele.
jesli jest 11 1n, to tam gdzie jest 1n to tam dajemy klucz glowny z tego przy 11. tam gdzie jest 11 to jest nadrzedne, a tam gdzie jest 1n to jest podrzedne.

rekrencyjne - jesli jet obowiazkowe po ou stronach, ze kazdy to ma, no to dostawiamy nowa kolumne, zmieniajac nazwe i tyle
alter table nazwa_tabeli add column 
	idszefa integer not null references pracownicy;
	
jesli jest po jenej stornie obowiazkwe, no to roibmy dodatkowaw tablilce gdzie sa dwa klcuze obce,
create table szefowie(
idszefa integer references pracownicy on delete set default on update set default,
idpracownika integer references pracownicy set on delete cascade,
);
i tera po prsotu tu wrzucamy,
podobnie jesli po obu stronach jest opcjonalnie, w tedy tak samo robimy.
zgodnosc referencyna - co się dzieje z kluczem obcym jeśli klucz główny do kotó©ego się odonsi sie zmieni lub zostanie usunięty?

create table nazwa_tabeli(
idczekoladki varcahr(5) references czekoladki on delay cascade on update cascade 
...
);

co ma sie dzic gdy klucz glowny zostanie usuniety - on delay
gdy zostanie zmienony - on update
mozemy robic

cascade
no action
restrict - zabezpoeiczenie ze nie mozna ruszyc tego klucz glownego jesli istnieje on w tej tabeli jako klucz obcy.
set default
set null
zaleznosc trywiala, to takak gdzie prawa storna jest podzbiorem lewej storny
AD -> A, AD -> D
imie, nazwisko -> nazwsko
BCNF - po lewej zawsze jest klucz / nadklucz
3NF - po lewej jest klucz lub po prawej są tylko kluczowe
2NF - nie ma sytuacji ze niekluczowy zalezy od czesci klucza
1NF - wsyzstkie wartsoci są atoiczne
zawszet rzeba policzyć najpierw wszsytkie klucze.

zalenzosc funckjnyaa
dopelnienie tranzytywne klucza H relaci R daje nam cala relacje R
z klucza funkcyjnie wynika cala relacja. znajac klucz otrzymujemy wszystkie dane z tej realacji.

trzeba zmienic nazwe i tyle
alter table nazwa_tabeli 
	set foreign key(nazwa_klucza_obcego) references tabela1;
zaleznosc funckyjna to wnisowkoanie jednych danych na postawie innych. nie zalezy od konrektnych wartsoci tych danych jakie sa w tabelach / kolumnach.
wynikaja ze schematu relacji a nie realacji jako takiej samej.
aby sie zwiekszal dajemy serial

create table nazwa_tabeli(
index serial primary key,
nazwa varchar(80)
);
alter table nazwa_tabeli add constraint nazwa_ograniczenia check(...);

alter table nazwatabeli alter column nazwa_kolumny set not null;
alter table nazwatabeli alter column nazwa_kolumny drop not null;

alter table nazwa_tabeli drop constraint nazwa_ograniczenia;


create table dzialy(
iddzialu char(5) primary key,
nazwa varchar(32) not null,
lokalizacja varchar(23) not null,
kierownik integer not null
);

create table pracownicy(
idpracownika integer primary key,
nazwisko varchar(32) not null,
imie varchar(16) not null,
dataUrodzenia date not null,
dzial char(5) not null,
stanowisko varchar(24),
pobory numeric(7,2)
);

alter table dzialy add constraint dzial_fk foreign key(kierownik) references pracownicy(idpracownika) on update cascade deferrable;
alter table pracownicy add constraint pracownicy_fk foreign key(dzial) references dzialy(iddzialu) on update cascade deferrable;

select * from dzialy;
select * from pracownicy;

select * into atakujace from...

insert into atakujace(nazwy atrybutow) values
select * from...;

alter table nazwa_tabeli
	add column nazwa varchar(40) check(length(nazwa) > 5);

not null
uniqe
primary key, ewentualnie na koncu w tabeli primary key(atr1, atr2) - przy bardziej zlozonych
default 2 / default nextval('nazwa_tabeli_nazwa_kolumny_seq')
check(warunek) check(premia<pensja)
foreign key(nazwa_kolumny_w_tej_tabeli) references tabela_glowna(nazwa_atrybutu_w_glownej);
mozna nazwac ograniczenia
constraint nazwa_ograniczenia check(pensja>permia);

create table nazwa_tabelki(
id1 integer,
id2 integer,
...
primary key(id1, id2)
);

create table kompozycje(
idkompozycji varchar(20),
nazwa varchar(20) uniqe not null,
opis varchar(200),
cena numierc(7,2) not null,
stan integer default 2
);

alter table kompozycja add constraint min_cena check(cena>=40.00);


select login || 'ALT', id+1, data_urodzenia, current_date into klienci from klienci 
where id_klienta = (select max(id_klienta) from klienci);


foreign key(i1, id2) references tabela1(id_1, id_2);

create table zamowienia(
...

primary key(idzamowienia),
foreign key(idklienta) references klienci on update set null,
foreign key(data_realizacji) references xd
);

3NF jest w tedy, kiedy po lewej stronie jest klucz, lub po prawej stronie są tylko kluczowe.
najpierw zawsze trzeba określić klucze w danym zbiorze, do 3NF da się ogarnąć zawsze.

2NF jest w tedy, kiedy nie ma sytuacji, że z częsci klucza wynika niekluczowy.
klucz to AD
A -> C - blad
AE -> B - okej, bo AE nie jest czescia klucza
A -> D - okej, bo D jest kluczowe

x.re - postgresql bedzie szukal tabeli o nazwie x a w nej kolumny o nazwie re
(x).re - mowi posgresowi, ze x jest typem zlozonym,a nam chdzoi o pole re. tak jak w javie, dostp do pola skladowego. w postgresql taki dostep, a abrdziej inforamcje, ze chozi nam o typ zlzoyn dajemy dodajac wlasnie te nawiasy.

alter table nazwa_tabeli rename column stara_nazwa to nowa_nazwa;

chodzi o to, aby referencje sie zgadzaly, przy usuwaniu uaktualnianiu.

alter table nazwa_tabeli 
	add constraint foreign key(id_uzytkownika) references userzy(id_usera) on delete set null on update cascade
	
mozna:

cascade
set null
set default
no action
restrict

alter table nazwa_tabeli
	add column cena numeric(7,2) check(cena>=40.00);

alter table nazwa_tabeli drop column cena cascade; -- pwszystkie powiazane tez usunie
alter table nazwa_tabeli rename column stara_nazwa to nowa_nazwa;
alter table nazwa_tabeli rename to nowa_nazwa_tabeli;

alter table nazwa_tabeli add constraint nazwa_ograniczenia foreign key(atrybut1, atr2) references siatkarki(iddruzyny, numer);

alter table nazwa_tabeli add constraint nazwa_ograniczenia check(pensja>premia);
alter table nazwa_tabeli add constraint nazwa_tabelki_pk primary key(atr1, atr2);

alter table nazwa_tabeli alter column cena set not null;

alter table nazwa_tabeli drop constraint nazwa_ograniczenia cascade ;

alter table nazwa_tabeli alter colkumn drop not null;

alter table nazwa_tabeli alter column nazwa_kolumny set default 2;
alter table nazwa_tabeli alter column nazwa_kolumny drop default;

alter table nazwa_tabeli alter column nazwa_kolumny type numeric(10,2);

drop from table nazwa_tabeli;

drop table nazwa_tabeli

drop table if exist nazwa_tabeli cascade
restrict
krotnosci - określenie ile maksmalnie i miniamlnlie może być "wysąpień" danej encji w relacji.
oznaczamy 1:* - gwiazda to nieskocznoność, nie ma ograniczegnia górnego.
1:1
1:n
n:n 

alter table nazwa_tabeli alter column nazwa_kolumny set default 2;
alter table nazwa_tabeli alter column nazwa_kolumny drop default;

BCNF - w tedy kiedy po lewej stornie zawsze jest klucz, wiec jest klucz albo nadklucz. 
zawsze przed okreslaniem postaci normalnej trzeba okreslic klucze danej relacji.
zawsze da sie zrobic, ale mozemy stracic zaleznosci funkcyjne.

select distinct(nazwa_atrybutow) from tabela;
select distinct nazwa_atrybutu, inny_atrybut from tabela;

tabele słownikowe - lepsza alternatywa dla enumow

create table nazwa_tabeli(
);

w wierszach sa dozwolone wartosci, dobre bo moga usrzy bez praw dodawac do tego kolejne wawrtosci np miasta, jesli kto doda krakow, to inni tez juz mogą dodawać.
latwy dostep do wszystkich dozwoloinych wartosci, mozna latwo przenoscic miedzy bazami danych

create table pora_roku(
nazwa varchar(10) primary key
);

albo 
create table pora_roku(
index serial primary key,
nazwa varchar uniqe not null
);

latwe usyznaknie zbioru dozwolonych wartosci, latwe aktualizaowanie zawartoscsi, ulatwiaja przenosnosc miedzy systemami baz danych.

alter table nazwa_tabeli drop column nazwa_kolumny cascade;

t true, 1, y yes, 'true',
n no f false 0 'false'

alter table nazwa_tabeli add column nazwa_kolumny numeric(7,2) uniqe not null default 2.0;
mozna dawac to co dla zwyklego tworzenia kolumny, wartsosci checki itp itd
alter table nazwa_tabeli drop column nazwa_kolumny cascade;
alter table nazwa_tabeli rename column stara_nazwa to nowa_nazwa;
alter table nazwa_tabeli rename to nowa_nazwa_tabeli;

alter table nazwa_tabeli add constraint nazwa_ograniczenia check(pensja>premia);
alter table nazwa_tabeli add constraint nazwa_ograniczenia_fk foreign key(atr1, atr2) referrences siatkarki(iddruzyny, numer);
alter table nazwa_tabeli alter column nazwa_kolumny set not null;
alter table nazwa_tabeli alter column nazwa_kolumny drop not null;
alter table nazwa_tabeli alter column nazwa_kolumkny set default 2;
alter table nazwa_tabeli alter column nazwa_kolumny drop default;
alter table nazwa_tabeli alter column nazwa_kolumny type numeric(10,2); -- powiedzie sie, jesli wszytkie wawrtosci mozna przekonwertowac, mozna dodac using() w celu okreslenia sposoboy konwersji.

drop table nazwa_tabeli;
drop table if exists nazwa_tabeli cascade; 
drop table if exists nazwa_tabeli restrict; -- nie bedzie mozna usunac jesli sa jakies odowolania do tej tabeli.
restrict
drop table if exists nazwa_tabeli;
sekewncje - generatory

create sequence seq1;
create sequence seq2 increment by 2 start with 1 min value 1 maxvalue 3 cycle;

craete sequence seq6 minvalue 1 maxvalue 3 cycle
create sequence seq7 increment by -1 maxvalue 5 start with 5 minvalue 1;

craete table nazwa_tabeli(
indeks integer primary key default nextval('seq1');
znak char
);
table slownikowe, ulepszenie enumiwo, latwy dostęp do zbioru wsyztkich mozllywch waratosci dozwolonych, mozna dodawac jako user, bez praw do pisania kodu, dynamicznie mozna,
latwosc przenoszenia itp itd, modyfikacji

craete table tabela_slownikowa(
index serial primary key,
nazwa varchar(10)
);
w wierszach sa dozwolone wartosci. 
przyspiesza uzyskiwanie zboru dopuszczalnych wartości dla atrybutu, łatwe aktualizowanie zawartości, ułatwia przenoścność między różnymi systemami baz danych.
rekurencje
wielu do wieu
złożone związki


wiele do wielu - tworzone jest pomoicncze, rozbijamy na dwie lub woecej reali 1 do n
np wizyty
userzy i nieruchoosci - dodajemy zbiór "wizyty" gdzie sa klucze jednego i drugiego + data wizyty // uwagi inne rzeczy.

rekurecnyjne - albo dostaiwamy do każdego kolkumne i tam jest klkucz obcy jako klucz glowny z tej tabeli
albo tworzoym nowa tabele gdzie parujemy dwa klkucze obce z tej saemj tabli, jeden jakko kierownik, drugi jako pracownik / podwładny

zlozone - rozbijamy na wiele realci jeden do n, tworzymy dodatkowy zbiór, i tam okresłamy jakie powinny być krotności. 

BCNF - po lewej zawzzse jest klucz
3NF - po lewej jest klucz lub po prawej sa tylko kluczowe atrybtuy
2NF - nie ma sytuacji, że niekluczoy zależy od części klucza (nie ma zalweżności funkcyjcnych częściowych)
1NF - wszytkie wartosc→ są wartoścami atomicnzinymi - to zakładamy że jest spełnione.

zawzses trzesba okreslić klucze, aby otrzymac roœneiż atrybtuy kluczowe.
alter table nazwa_tabeli add column nazwa_kolumny numeric(7,2) constraint check(cena>=40.0);
alter table nazwa tabeli drop column nazwa_kolumny cascade;
alter table nazwa_tabeli rename column nazaw_kolumny to nowa_nazwa;
alter table nazwa_tabeli rename to nowa_nazwa_tabeli;
alter table nazwa_tabeli add constraint nazwa_ograncizenia check(pensja>premia);
alter table nazwa_tabeli add constraint tabela_fk foreign key(atr1, atr2) references siatkarki(iddruzyny, numer) on update cascade;
alter table nazwa_tabeli drop constraint nazwa_ograniczenia;

alter table nazwa_tabeli alter column cena set not null;
alter table nazwa_tabeli alter column cena drop not null;
alter table nazwa_tabeli alter column cena set default 2;
alter table nazwa_tabeli alter column cena drop default;
alter table nazwa_tabeli alter column type numeric(10,2); -- zadziala, jesli wsztkie wartosci w tej kolumnie mozna przekonwertowac na ten typ, mozna uzyc using() aby okreslic typ konwersji. 
drop table if exists nazwa_tabeli restrict albo cascaade
drop table nazwa_tabeli;
drop table if exists nazwa_tabeli restrict;
drop table if exists nazwa_tabeli cascade;
alter table nazwa_tabeli add constraint nazwa_ograniczenia check(pensja>premia);

alter table nazwa_tabeli alter column cena set not null;
alter table nazswa_tabeli drop constraint nazwa_ograniczenia;
alter table nazwa_tabeli alter column cena drop not null;
alter table nazwa_tabeli add constraint nazwa_ograniczenia foreign key(atr1, atr2) references siatkarki(iddruzyny, numer) on update cascade 
on deley no action

set null
set default
cascade
restrict
BCNF - po lewej klucz lub nadklucz
3NF - po lewej klucz lub po prawej tylko kluczowe
2NF - nie ma sytacji, ze niekluczowy zalezy od części klucza
1NF - wszsytkei wawrtości są atomiczne

trzeba zawsze wyznaczyc klucze i tez atrybuty kluczowe.
1.
select nazwisko, wiek, pobory*12 from pracownicy order by pobory desc, nazwisko;
2.
select nazwisko, imie, dataUrodzenia, stanowsiko, dzial, pobory where
stanowsiko in ('robotnik', 'analityk') and pobory > 2000.0;
3.
select nazwisko, imie from pracownicy where
pobory > (select pobory form pracownicy where imie = 'Adam' and nazwisko = 'Kowalik');
4.
update pracownicy
set pobory = pobory * 1.1
where stanowisko = 'robotnik';
5.
select stanowisko, avg(pobory), count(*) from pracownicy
where stanowisko <> 'kierownik'
group by stanowisko;
trzeba dodać za pomoca 
alter table nazwa_tabeli add constraint tabeli_fk foreign key(atr1, atr2) references tabela2(iddruzyny, numer);

mozna nazywac kluzce obce, najlepeij jest dawac zalenzosci na samym koncu kedy wsyztkie tabele sa juz utworzone, albo jest flaga ktora zapewnia, ze wiezy poprawnosci sa sprawzane przed samym koncem tranzackji.
klucz obcy jako foreing key
nalezy dać not null do klcza obcego.

deferrable;
references bar(id) deferrable;
BCNF - po lewej klucz ablo nadklucz
3NF - po lewej klucz lub po prawej tylkok kluczowe
2NF - nie ma sytuacji, że niekluczowy zależy od części klucza.
1NF - wszytkie atrybuty są atomiczne - atomowoe, nie można ich podzielić na żadne mniejsze części.
zawsze trzeba wyznaczyć klkucz oraz atrybuty kluczowe.
1.
select nazwisko, wiek, pobory*12 from pracownicy orer by pobory desc, nazwisko;
2.
select nazwiso, imie, dataUrodzenia, stanowsiko, dzial, pobor from pracownicy 
where stanowsiko = any ('analityk', 'robotnik')
where stanowsiko in ('analityk', 'robotnik')
and pobor > 2000;
3.
select naziwsko, imie from pracownicy where 
pobor > (select pobor from pracownicy where imie = 'Adam' and nazwisko = 'Kowalik');
4.
update pracownicy
set pobory = pobory * 1.1 
where stanowisko = 'robotnik';
5. 
select stanowsiko, avg(pobory), count(*) from pracownicy
where stanowsiko <> 'kierownik'
group by stanowisko;
klucz glowny atuomatyczne zwiekzanie
ablo 

create sequence seq1;
create table nazwa_tabeli(
id integer primary key default nexval('seq1');
nazwa char(10)
);

albo 
create table nazwa_tabeli1(
id serial primary key, -- to tworzy sequence 'nazwa_tabeli1_id_seq' i ma default nextval('stworozna sekwernsja'). ten typ jest oczoywiscie integer
nazwa char(10)
);
create sequence seq1 increse by 2, maxval 5, startval 1 cycle;
x is not distinct from y;
x = y, jesli ob nulle to true, 
gdy awrtsoci to = 
gdy jeden null drugo cos inngo to false
x is not distinct from y
x is not distinct from y;
create table nazwa_tabeli(
id serial primary key,
nazwa varchar(20)
);

albo
create sequence seq1; -- increment by 1;
create table nazwa tabeli1(
id integer primary key default nexval('seq1'),
nazwa varchar(20)
);
create table diety(
id_diety serial primary key,
nazwa...
);

albo 
create sequence diety_id_diety_seq; -- increment by 1 startval 0

craete table diety(
id_diety integer primary key default nextval('diety_id_diety_seq');
...
);
BCNF - po lewej jest klucz ablo nadklucz
3NF - lewa jest klucz lub prawa sa tylko kluczowe
2NF - nie ma sytuacji, aby niekuczowy zalezal od czesci klucza
1NF - wszystkie wartosci są atomiczne
wyznaczamy se klkucze, potem  z tego mamy kluczowe, i oto woda, co stoi na przeszkodzie, sprawzamy kotre warnuki sie zgadzaja, jesli nie jest w nizszej, to nie myze byc w wyzszej, jesli jest w wyzszej to na pewno jest w nizszej (chyba z wyjatkiem 1nf)
select possition('a' in 'ala) -> 1 bo liczxymy od 1 w sqlu
zaleznosci funckyjne - trzba policzyc rzuty na wszytkie h, i potem jesli domkniecie tranzytywne sumy naszych rzutuow, jesli z tego domkniecia wynika funkclyjne / logicznie, no da sie wyprowadzić wszystkie zalenzosci z h, to w tedy taka dekompozycja zachowuje zaleznosci funkcyjne.
drop table nazwa_tabeli;

drop table nazwa_tabeli restrict/ cascade
powoduje usuniecie wsyzktich powiazanych zalenoszsic, ogrnaczien, licznikow, generaotrow, wyzwalaczy itp itd
drop table if exists nazwa_tabeli cascade / restrict
create table temporary nazwa_tabeli(
id serial primary key,
nazwa varchar(40) constraint nazwa_ograniczenia check(length(nazwa) > 5),
id_zewnetrzen not null foreign key references tabela(id_glowne) on update cascade
);

rozszerzac, mozna dodawac
alter table add constraint nazwa_ograniczenia
	foreign key(iddruzyny, numerek) references siatkarki(iddruzyny, numer) on update cascade;
alter table add constraint nazwa_ograniczenia2
	check(premia<pensja);
alter table add column nazwa_kolumny varchar(23) not null;
inherits - dziedziczczymy po jakeijs innej tabeli
BCNF - po lewej tylko klkucz albo nadklucz
3nf - po lewej jest se kllucz / nadklucz, no oglnie zawiera w sobie klucz, lub po prawej stornie są tylko atrubyty kkuczowe, wszytkie po prawej stronie mszą być klkuczowe.
2NF - wsyztko te, kto©e nie zaweirają zależności funkcyjnej częściowej, czyli takiej, w której element niekluczowy ( nie jest częścią żadnego kluzca)  zależy od części klucza.
1NF - wszytkeie watości atrybutów są atomiczne - nie da się ich już rozdzielić w żaden sposób.
zawszse na początku trzba wyzaczyć wszytkie klucze, nastepnie z tego mamy atrybuty kluczowe, na tej postawie możemy dalej określać w jakiej postaci normalnej co się znajduje.
T jest kluczowe, bo nie znajduje się po prawej stornie żadnej z produkcji, więc w klkuczu musi występować T.
nie jest w 2nf, bo kluczami są TG i TP, natomiast zależność funkcjyna P -> W. W nie jest kluczowe i zależy od częsci klucza (P jest częścią klucza) więc nie jest w 2nf. jest w 1nf.
jakby było PA ->W to to by było git, bo PA nie jest częscią podklucza, patrzymy na cała lewa cześć a nie na poedyńcze atrybuty.
trzseba zrobic 

create temporary table pracownicy(
id_pracownika serial primary key,
id_szefa integer,
imie varchar(20)
);

alter table pracownicy add constraint pracownicy_id_szefa_fk
	foreign key(id_szefa) references pracownicy(id_pracownika);
treba zrobic 
alter table wives add constraint wives_husband_fk
 foreign key(kusband_id) references husbands(id);
 
alter table husbands add constraint husbands_wife_id_fk
foreign key(wife_id) references wives(id);
bierzemy lewa strone tej zalenosci fucnkyjne, i stusując zależności funkcyjne z F
obliczamly domknięcie tranzytywne. jeśli w omknięcu tranzytywnym znajduej się to co
jest po prawej stornie spawdzanej zależności fun ckjynej (może być więcej, więcej nas nie obchodzi)
no to jeśli jest, to zanczy że ta zależność należy do F+, bo z F można to wywnioskować (mając to co jest danee po lewej stornie)
create table zawartosc(
idpudelka char(4) not null,
idczekoladki char(3) not null,
sztuk integer
);
alter table zawartosc add constraint zawartosc_pk
primary key(idpudelka, idczekiladki)

alter table zawartosc add constraint zawartosc_idpudelka_fk
 foreign key(idpudelka) references pudelka;
alter table zawartosc add constraint zawartosc_idczekoladki_fk
foreing key(idczekoladki) references czekoladki;

serial 
aalter table nazwa_tabeli alter column nazwa_kolumny type numeric(10,2);
- dokona się tylko w tedy, keidy kazdy rekord można zamienić na ten nowy typ.
można użyc 
using() aby określić w jaki sposób ma zostac dokonana konwersja pomiędzy typami, stary a nowy.
podzapytanie to zapytanie które jest częścią innego zapytania, mogą być zagnieżdzone dowolną ilość razy wewnątrz siebie. zwykłe select, ale musi być  typie
(select ....)
mamy 
skalarne - jedna wartosc
krotkowe - krotka jeda 
relacyjne -  tabela
gdy porownujemy, podzapytanie mus byc po prawej stronie. jeśli chodzi o tabele w from, to muszą mieć alias zrobiony, abyśmy mogli się do tego odnosić.	
podzapytnaia trzeba dawać w ()
where nazwa in (select nazwa from ....;)
binarne związki 1 do 1, no to łączymy je do jednej tabli, wyiberamy sobie klucz główny. 1-1 1-1, nie mogą istnieć bez siebie
jeśli jest 
11 1-n no to tam gdzie jest 1-n to wstawiamy klucz z tego 1:1
jesli po obu sronach jest 1-n 1-n, no to wybieramy ktory jet ważniejszy, ewetnaulnie pośrednią robimy. 
podzapytanie moze się odnosic do atrybutów z otaczającego go zapytania, poprzez korpke
nazwa_tabeli.atrybut. w tedy takie zapytania są nazywane skorelowanymi, bo ich wynik zależy od otoczenia. takie podzapytanie jest wykonywane na nowo przy każdym obiegu "pętli" w senise dla każdego rekodru jest liczone poononwie, dzięki temu wartość zwracana przez podzapytanie jest / może być różna dla każdego z rekordów.

select nazwsiko, imie (select max(punkty) from punktujace where punktuajce.numer = siatkarki.numer and punktujace.iddruzyny = siatkarki.iddruzyny) as maksimum from siatkarki order by maksimum desc;
porównanie z podzapytaniem, podzapyanie musi byc po prawej stornie 

wyliczeniowe - enum 
create type pory_roku as enum('wiosna', 'lato', 'jesien', 'zima');
i tera ta, tam gdzie jest skonczony zbor mozliwych wartosci, lepiej jest sotosowac tablice / tabele slownikowe - tabele z wartoscami dozwolonymi, ewentualnie domeny - typy proste z ogranizeniami narzuconymi, np kod pocztowy '[0-9]{2}\-[0-9]{3}'
ale tak to uporzadkowaene sa w takiej koklenosci jak dodalismy, jesli chemy porownac dwie wartosi enumow to musimy je zrzutowa na stringa. 
wielkkosc liter ma znaczenie.
używać możemy jak kazdego innego typu 
create table sezony(
rok ineger,
pora pora_roku,
primary key(rok, pora)
);

insert into sezony values(1, 'wiosna');
insert into sezony values(1, 'wiosenka'); - nie przejdzie, bo sie nie zgadza z enumem.
do sprawdzania poprawnosci danych np.
select nazwisko, imie (select max(punkty) from punktujace p where p.iddruzyny = s.iddruzyny and p.numer = s.numer) from siatkarki s;
to jest z uzyciem podzapytania skorelowanego, bo odwolujemy sie do elementow z zapytania otaczającego. można sie odwoływac do atrybutów ze wszystkich wyższych podzapytań, tak jakby pętla w pętli w pętli , etc. trezba dawać aliasy, albo po prostu całe nazwy. przy tabelach nie używamy słówka 'as' tylko po prstu from punktujace p, from siatkarki s.
as używamy w sekcji select. select max(punkty) as maksimum,  
w podzapytaniu nie mozna używać formuly order by, bo to jest bez sensu. bo i tak jest to jako zbior przekazywane
select nazwisko, imie, punkty from siatkarki natual join punktujace
where punkty >= ((select max(punkty) from punktujace) - 5); -- czyli te ktora maja maxa aalbo maksymlanie 5 mniej.
podzapytanie to zapytanie ktore jest częscią większego zapytania. jest w nawiasach (), może się odwoływać do atrybutów z otaczającego go zapytania, w tedy jest to podzapytanie skorelowane, jeśli nie odwołuje się, to jest to nieskolerowane. nieskolerowane podzapytania zwracają za każdym razem taki sam wyniki, oraz możey je uruchomić niezalżnie, tak jak każde inne zapytanie.
są rodzaje podzpaytań
skalarne - pojedyńcza wartość.
krotkokwe - pokedyńcza krotkia, rekord, kilka wartości w senise jakko kilka atrybutóœ ale każdego atrybutu jest tylko jedno wystąpienie.
relacyjne - tu jest zbiór krotek - cała relaja, tabela
Podzapytanie może się odwoływać do otacającego go zapytania, w teyd jest to podzpytanie skorelowane, domyslnie w danym zapytaniu, nazwy atrybutów odnosza sie do tego konrkegnoeg, jesli chcemly do wyżsych, to najpeirw nazwę ich tabeli, nazwy z ich zpaytnaia from. najczęsiej sie robi aliasy aby n ie pisć doużo, przy formule from dajemy po pseoty aloas
typu 
from siatkarki s, from punktujaace p. natomiast w sekcji select dajemy as 
select (imie || ' ' || nazwisko) as dane_osobowe
select max(pkt) as max i tak dalej.

select nazwisko, imie, (select max(punkty) from punktujace p where p.iddruzyny = s.iddruzyny and p.numer = s.numer) as maksimum from punktujace natural join siatkarki s; 
ewentualnie zamist aliasow byloby punktujace.iddruzyny = siatkarki.iddruzyny and punktuajce.numer = siatkarki.numer)
Minimalny zbior zalezności 
1. ma tylko zalenosci proste - po prawej stornie są pijedyńcze wartośći
2. nie ma regół które da się wypporwadzić z innych pozostałych
3. nie ma nadmiarowości, jeśli mamy dwiereguly ktore produkuja to samo, a lewe storny, jedna jest podzbiorem drugiej, to bierzemy tą m nijszą, ten podzbiór np
A -> B
AC -> B. nie potrezbuejmy tej, ona jest nadmiarowa.
select nazwisko, imie punkty from siatkarki natural join punktuajce
where punkty >= ((select max(punkty) from punktujace) - 5)
order by punkty desc;
select nazwa, miasto from druzyny d
where 25 < (select sum(punkty) from punktujace p where p.iddruzyny = d.iddruzyy)
albo
selct nazwa, miasto from druzyny wehre iddruzyny in (select iddruzyny from puntkuajce where punkty > 25);    

select nazwa, miasto from druzyny d
where exists (select 1 from punktujace p natural join siatkarki where p.iddruzyny = d.iddruzyny and  punkty > 8 and pozycja = 'rozgrywajaca');

select nazwa, miasto from druzyny d
where not exists (select 1 from punktujace p natural join siatkarki where p.iddruzyny = d.iddruzyny and punkty > 25);
nazwa = any / all (... podzapytanie) 
= < > >= =< <>
not 
= any == in 
<> all == not in
bo z algebry, prawo demorgana i tak dalej.

cena > any (select cena from..)
cena <> all (select cena...)
obowiazkowe i - jedna tabela i dwie falgi, - dyskryminatory ? ktore okreslajaj ktora werjsa jest, jaki jest typ
opcjonalne i - tworzymy dwie tablice. jedna z samym wlasniicelem, i druga ze szczegolami, gdzie dajym dwie fali - dyskryminatory ktore okreslaja ktora szcczegoly sa. do tej drugiej daiemy id z glownego, z klienta, ze jeslu jest rekord, toznaczy ze ten wlasncieel jest jedym z tych dwoch 

obowiazkowe lub -jedna tabela oddzielnie dla kazdego. w senesi dwie tablee, gdzie w kazdej jest pelna zawrtosc wlasciciela oraz dodatkowe wartosci. mozna przy tworzeniu nac inherits wlasciciele. w tedy sie skopuja tabele i ograniczenia ( chyba też ??)
opcjonalne lub - tworzymy trzy table, n tabel +1, jedna głowa dla samego wlasiciela, i po jeden dla kazdego z mozliwych podgrupp. 
<> any - nie wszystkie sa takie same
<> all - jest unikatory

x >= all (select x from ) - zwraca wszytkie nulle, jesli bezdie null, to tu beze pusto, bo neie ma pwoneosci, cxzy x jest wiekszy od tego co kryje sie pod nullem.
x >= (select max(x) from)... - pomija nulle, 
rekurencje, jesli est n do n rekurencyjnie, to najlatwiej dodatkwa tabele, rozbic na dwie 1-n 1-n i w tedy jest wsyztko git. taka dodatkowa tabela pokazuej zależńości między konkrentymi krotkami z tabeli głównej. 
x >= all (select x from)
x >= (select max(x)) - max pomija nulle, i tu sie wkona z pominieciem nulli, w piersyzm przyadku, jesli byłby null, to będzie pusto, bo sql nie wie co jest wiesze x czy  null, pod kotrym moze byc dowolna wartosc.
select * from druzyny;
select nazwa, miasto from druzyny 
--where iddruzyny in  (select iddruzyny from punktujace where punkty > 25);
where iddruzyny = any (select iddruzyny from punktujace where punkty > 25);
to w tedy bedzie problem, bo nie wiadomo czy jest cyz nie, nie wiemy co sie kryje pod tym nullem.
dosatemy pusta relacje, bo nie wiadomo. 
dekompizycja bezstatna jest w tedy, kiedy po dekompozycji otrzymujeym wsyztkie dane,
zlaczenie naturalne naszej dekompozycji da nam cale poczatkowe F bez zanych dodatkowychr
zeczy oraz niczego nie będzie brakowało.
najcześciej ablo tabelką to robumy,
ewetualnie patrzyy na część współną rozbić, liczxymy jej domkniecie i jesli w tym domkniecy tej częsci wspolnej zawera się jedno z rozbić( w sensie, w domknięciu tranzytywnym części wspólnej sa wslyztkie atrybuty z któregoś z rozbić., to w tedy jest to bezstarta) ale łatiwej i bezpiezniej robić to za pomocą tabeli.
 możemy sprawedzić 
where exists - wybiera te, gdzie istneiej chociaz jedna wartość
where not exists 
przydatne kiedy interesuej nas tylko to czy cos instieje czy nie, naczjesciej zwracamy 1 w ttym podzapytaniu.


select nazwa, miasto from druzyny 
where exist (select 1 from punktuajce natura join siatkarki where p.iddruzyny = d.iddruzyny and punkty > 8 and pozycja = 'rozgrywajaca');

select nazwa, miasto from druzyny d
where not exists (select 1 from punktuajce p where p.iddruzyny = d.iddruzyny and punkty > 25);
< > >= =< <> =

element > any (select ceny from...) - jesl element jest wiekszy od ktoregokolwek z elementow 
element > all (select ceny from...) - jest wiekszy od wszytkich

element <> all (select ..) == element not in -> jesli jest rozny od wszytkichs
element <> any (slenect...) => jest rozny od ktoregokoliwe, wystarczy ze w select będą dwa rozne elementy, to ten wruenk przejdzie.

nazwa <> all (select nazwy) -> nazwa jest unikatowa, nie ma drugiej takiej w zbiorze ktory został przekazany przez select.
exist -> joinami, bardzo czesto zastepujemy, bo tak jest latwie i prosciej najczesciej.
labo po prsotiu joiny, albo left join where prawy.klucz = null
element <> any - niebiezpieczne,
element <> all -> jest unikatowy 

in => = any
not in => <> all 
bo z praw demorgana sie zmienia negacja i symobl z dodawania na mnozenie.
jesli ejst pozpayatnie w klauzuli form, to musi miec aliast nadany, tak aby sql sie nie gubil 
i abysmy mieli dostep do pol ktore w tym są.
select ... from (select ....) p;
x >= all (select x from....) - tutaj, zwarca wsztki x, a porównanie z nullem zwarca null, bo nie wiadomo czy x jest rowny tego co sie kryje pod nullem albo czy to co jest w nullu jest mniesjze od x
x >= (select max(x)) -> max pomija wartosci nulli, gdyby się pojawiło, to nie zwraca tego, 
zachowuje zależności funckjyne - muimy policzyć rzuty dekompozycji,
a potem liczymy zależności funckjyne używając tylkko tego co mamy w rzucie.
i teraz jeśliz dopełnienia sumy tych zbiorów zależności funckynych (sumy zależności które utrzymaliśmy w rzutach)
funkcune wynila całe F to onaza, że dekompozyca zachowuje zależności funkcjyne.
za pomocą having - już odnosi się d zgrupownych wyników, możemy np ś©ednia punktóœ ( juz w grupie jedej) albo suma punktów w tej kkonrketnej grupie.
dla każdej grupy to co tu damy w having jest liczone oddzielnie.
najpeirw jest duży zbiór ciasto, potemw wyberamy te elementy kto©e spełńiają where, następnie grupoujemy je , łączymy w grupy, i następnie analiziujeym każdą grupę z osoba pod
kątem tego czy spełnia to co daliśmy sobie w having. jeśli dana grupa spełnia, to ją bierzemy, jeśli nie spełnia, to odrzucamy i tyle.
zgodność referencyjna - co ma się dzać gdy coś się dzieje z kluczem obcym np

create table nazwa_tabeli(
indeks serrial primary key,
iddruzny integer not null
);

alter table nazwa_tabeli add constraint nazwa_tabeli_iddruzyny_fk 
	foreign key(idduzyny) references druzyny(iddruzyny) on update cascade on delete

on update on delete

cascade - robi to co sie dzieje z kuczem do ktego sie odnosimy.
no action - nic nie robi
set null - ustawia nula
set default - usawia wiartsoc domolsnia
restrict - nie pozwala zmienic jesli sa odniesienia
-- obliczenie sumy punktow dla kazdej druzyny w kazdym meczu.
-- jeden rekord to jeden mecz i konkretna druzyna
-- nastepnie grupujemy te wyniki po nazwie druzyny, więc w kazdej grupie mamy w kazdym rekordzie
-- ilosc punktow jaka zdobyla druzyna w danym meczu. rekordow jest tyle ile rozgrywek rozegrala dana druzyna.
-- nastepnie w kazdej z grup (czyli dla każdej druzyny) średnią, czyli sumujemy wszytkie punkty i dzielimy
-- przez ilosc rekordow, bo tyle bylo mezcy

-- dostajemy srednia ilosc punktow zdobytych przez kazda z druzyn na jeden mecz.
with x as (
    select idmeczu, iddruzyny, sum(punkty) as pkt
    from punktujace
    group by idmeczu, iddruzyny)

select nazwa, avg(pkt)::numeric(7,2) srednia
from x natural join druzyny
group by nazwa
order by srednia desc;
with x as (select idmeczu, iddruzyny sum(punkty) as pkt from punktujace group by idmeczu, iddruzyny)

select nazwa, avg(pkt) from druzyny natural join x
group by nazwa;
dzielimy, czyli otrzyjmujemy tylko te rekordy ktore spełńiają wszytkie wartości z wymieionyhc.

napierw tworzyym idealny swiat - iloczyn karteznajski, a nastpenie idejmujemy stan rzeczywisty - jesli ktos umie i jeden i drugi, no to bedzie usuniety z tego.
i w tedy jesi id tej osoby nie znajduej sie w "brakujących" to oznacza że spełnia wszytkkie nasze wymagania.
lepsze od zwykłęgo

' '
'.'
'[abc]
'[a-c]'
'\*'
{
x
^ negacja w
'[^a-z]'
zakres 
'[a-z]'

* - 0 lub wiecej
+ - 1 lub wiecej
? - 0 lub 1
.{10}
.{5,}
a{5, 10};
do max 255
'^poczatek koniec$'
 .{10}
 
.* - dowolna ilosc arzy
.? - 0 lub 1
.+ - 1 lub wiecej
[a-z] od a do z
[a-z]{10}
(01)
-- ==================================================
-- zmiana typu kolumny uzywajac using(...)
-- ==================================================

-- select * from klienci;

CREATE TEMPORARY TABLE klienci_tmp AS
SELECT * FROM klienci;

--select * from klienci_tmp;

--select length(nazwa) from klienci_tmp;

alter table klienci_tmp add column dlugosc_nazwy integer;

update klienci_tmp set dlugosc_nazwy = length(nazwa);

-- select * from klienci_tmp;

-- alter table klienci_tmp alter column nazwa type integer; -- wywali, bo nie moze autoamtycznie

select * from klienci_tmp;

-- mowimy w jaki sposob ma zamienic, uzywa tego co jest w using. to co jest w
-- using ma zwracac typ ktory jest zgodny z nowym typem tutaj zapewnie można też
-- wrzucić funkcję jakąś.

alter table klienci_tmp alter column nazwa
type integer using(length(nazwa));

select * from klienci_tmp;
alter table nazwa_tabeli add column nazwa_kolumny numeric(7,2) not null;
alter table nazwa_tabeli drop column nazwa_kolumny cascade;
alter table nazwa_tabeli add column nazwa_kolumny numierc(7,2) primary key;

alter table nazwa_tabeli rename column stara_nazwa to nowa_nazwa_kolumny;
later table nazwa_tabeli rename to nowa_nazwa_tabeli;

alter table add constraint tabela_iddruzyny_fk foreign key(iddruzyny) references druzyny(iddruzyny) on update cascaade;

alter table nazwa_tabeli alter column nazwa_kolumny set not null;
alter table nazwa_tabeli drop constraint nazwa_ograniczenia cascade;
alter table nazwa_tabeli alter column nazwa_kolumny drop not null;

alter table nazwa_tabeli alter column nazwa_kolkumny set default 2;
alter table nazwa_tabeli alter column nazwa_kolumny drop default;

alter table nazwa_tabeli alter colkumn nazwa_kolunny type numeric(10, 2); -- uda się tylkko w tedy kiedy kadza wartosc mozna przekonwertowac do nowego typu, mozna uzyc klauzuli using() aby okreslic w jaki sposob ma przebiegac konewrsja

drop table nazwa_tabeli;
drop table if exists nazwa_tabeli cascade, restrict, 
with x as (update kompozycje set cena = cena * 1.1 returning *)

select * from x;

używając klauzuli returning możemy zwracać wartości któ©e są edytoane, usuwane, dodanaw
szuka wszedzie,

(ar) - konrektny znak
.
[a-c]
\* - szuka * 
[^a-z] - bez a b c d e.... 
[a-z]

* - 0 lub wiecej
+ - 1 lub wiece
? - 0 lub 1 
.{10} - 10 dowolnego znaku
[0-9]{10} - 10 liczb
.{10,} - conajmniej 10
.{5, 10} od 5 do 10  włącznie aaaaaaaaaa = 10 a, też się zaliczy, 11*a już nie wejdzie
te lizby tylko z przedziało 0 do 255 ( bo 8 bitów 256 mozliwosci, wiadomka)o co cho
^ - poczatek znaku 
$ - koniec znaku
'^al.*k$'
~ ~* !~ !~*
funkcje sterujac,e 
proceduralny, definowaenie fucmki i wyzwalaczy, 
rozszeża o sterująceg, 
zgrupowanie ciągu instrukcji w ramach funckji która jest przechowwana na serverze,
zmniejsza ilość potzrenbych danych do przeszucania przez sieć, daje większe bezpieczeństwo i sprawdzenie ze wsztko działa tak jak powinno dizałać.
funckjemogą przyjmiwać i zwracać wartosic typuw sklarnych jaki tablicowe
skalarne, krotkowie, relacyjne. polimoriczne - any, zbiory rekdorów itp itd, jesli jest
any type i any array, to musza być powiązane, any array musi byc złoózony z anytype. mozemymmiec wieel zmiennych o anytype,
ale w wywolaniu wsyztkie te wartosci musza mieć taki asm typ
np wsytkie to inty, innym razemw szytkie to varchary itp itd. musi byc zgodnośc
alter table nazwa_tabeli add column nazwa_kolulmny type
alter table nazwa_tabeli add column cena numeric(7,2) constraint cena_minimalna ckeck(cena >= 40.00);

alter table nazwa_tabeli add colkumn cena numeric(7,2) unique not null;

alter table nazwa_tabeli drop column nazwa_kolumny cascade;

alter table nazwa_tabeli rename column nazwa_kolumny to nowa_nazwa_kolumny;

alter table nazwa_tabeli rename to nowa_nazwa_tabeli;

alter table nazwa_tabeli add constraint nazwa_tabeli_iddruzyny_fk foreign key(iddruzyny) references druzyny(id) on update cascade;

alter table nazwa_tabeli alter column nazwa_klumny set not null;
alter table nazwa_tabeli alter column nazwa_kolumny drop not null;
alter table nazwa_tabeli drop constraint nazwa_ograniczenia cascade;

alter table nazwa_tabeli alter column nazwa_kolkumny set default 5;
alter table nazwa_tabeli alter column nazwa_kolkumny drop default;

alter table nazwa_tabeli alter column nazwa  -- wczesniej bylo varchar(20)
type integer 
using(lenght(nazwa)); -- uda sie tylko w tedy koedy da sie przekonwertowac, jesli ejst to trywialne to zrobi sie autaomatycznie, 
dropo table nazwa_tabeli cascade restrict

drop table if exists nazwa_tabeli cascade restrict
cascade - usuwa tez wsyztkie z ta powiązane
restrict - nie pozwala usnunąć jesli istneija jakies powiazania.
if exist - tylko w teday kiedy istneije, jak nie istnieje to to pomija.
create function nazwa_funkcji(in cena numeric(7,2)) returns numeric(7,2) as
$$
declare
	zmienna varchar(20);
	cena1 numeric(7,2);
begin

	return;
end;
$$
language plpgsql;


zmienne w declare,
kkompilowan jest dopeiro przy poeirwsyzm uruchomieniu funkcji, sa uzanwane za dwie rozne, jesli maja rozne nazwy, lub rozne arguemnty, lub ronze typy argumentow
create function nazwa_funkcji(cena numeric(7,2)) returns numeric(7,2) as
$$
declare
	zmienna integer;
	zmienna2 numeric(7,2);
begin

end;
$$
language plpgsql;
ale więcej w pliku se bedzie
drop function nazwa_funkcji(numeric(7,2));
create or replace function suma_zamowien(id_klienta_v integer)
returns numeric(7,2) as
$$
declare
    suma numeric(7,2);
begin
	select sum(sztuk*cena) into suma
    from zamowienia natural join artykuly natural join pudelka
	where idklienta = id_klienta_v;
    return suma;
end;
$$ language plpgsql;

select suma_zamowien(7);

create or replace function rabat2(id_klienta_v integer)
returns numeric(7,2) as
$$
declare
	suma numeric(7,2);
	wartosc_rabatu numeric(7,2);
begin
	select suma_zamowien(id_klienta_v) into suma;
	wartosc_rabatu = suma * case
        when suma < 75 then 0.05
	    when suma between 75 and 110 then 0.07
	    else 0.08
    end case;
	return wartosc_rabatu;
end;
$$ language plpgsql;
select rabat2(7);

create or replace function rabat2(id_klienta_v integer)
returns numeric(7,2) as
$$
declare
	suma numeric(7,2);
begin
	select suma_zamowien(id_klienta_v) into suma;
	return suma * case
        when suma < 75 then 0.05
	    when suma between 75 and 110 then 0.07
	    else 0.08
    end case;
end;
$$ language plpgsql;


select rabat2(7);

create or replace function sumaZamowien(_idklienta integer) returns numeric(7,2) as
$$
declare
	suma numeric(7,2);
begin
	select sum(cena*sztuk) into suma
        from zamowienia
        natural join artykuly
        natural join pudelka
        where idklienta = _idklienta;
	return suma;
end;
$$ language plpgsql;

select sumaZamowien(7);
-- kod jest kompoilowany w tedy kiedy pierwsy raz uruchomimy funkcję, i dopierio w teyd mozemy sprawdzic czy wszytko sie zgadza.
kiedy jest ina nazwa, lub inny typ parametrow, lub inna liczba parametrow

deklarujemy w sekcji 
declare
klamry robimy za pomocą $$ $$
create or replace function testowa(cena numeric(7,2)) returns numeric(7,2) as
$$
begin
	if cena < 0.0 then
        raise exception 'nieprawidlowa cena %, %', cena, $1; -- ablo $1 - odwołanie do atrybutow
    else raise notice 'licze dla %', cena;
    end if;
	return cena;
end;
$$ language plpgsql;

select testowa(4.4);
select testowa(-4.4);

create function nazwa_funkcji(cena numeric(7,2)) returns numeric(7,2) as
$$
declare 
	zysk numeric(7,2);
begin
	if cena<0.0 then raise exception 'Nieprawidlowa cena %', $1; -- lub zamist $1 można dać cena
	else raise notice 'Liczymy dla: %', cena;
	end if;

	zysk = case 
		when x < 10 then 0.05 
		when x between 50 and 199 then 0.6
		when x between 200 and 400 then 1
		else 2;
		end case;
end;
$$ language

create function rabat3(id_klienta_ integer) returns numeric(7,2) as
$$
declare
	suma numeric(7,2);
    rabat numeric(7,2);
begin
	suma = sumaZamowienia3(id_klienta_);
	rabat = suma * case
			when suma < 75 then 0.05
			when suma between 75 and 110 then 0.07
			else 0.08
		end case;
	return rabat;
end;
$$ language plpgsql;


create function sumaZamowienia3(id_klienta_ integer) returns numeric(7,2) as
$$
declare
	suma numeric(7,2);
begin
	select sum(cena*sztuk) into suma from zamowienia natural join artykuly natural join pudelka where idklienta = id_klienta_;
	return suma;
end;
$$ language plpgsql;

select sumaZamowienia3(7);
select rabat3(7);

if cena < 0.0 then raise exception 'Nieprawidlowa wartosc dla ceny: %', cena;
else raise notion 'Licze dla: %', $1;
end if;

create function nazwa_funckji(cena numeric(7,2)) returns numeric(7,2) as
$$
declare
	sum numeric(7,2);
begin
	if cena < 0.0 then raise exception 'Nieprawidlowa cena %', cena;
	else raise notice 'Licze dla: ', $1; 
	end if;

	return numeric(7,2);
end;
$$ language plpgsql;
BCNF - po lewej zawsze jest klucz
3nf - po lewej zawze jest klucz lub po prawej są tylko kluczowe
2nf - nie ma zalezżnośći częściowych. atrybuty niekluczowe nie mogą zależeć od częsci klucza.
1nf - wsyztkie atrybuty są atomiczne - nie da się ich ppodzieic.

nazwa record

musi być tylo jeden weirsz

jest zmienna found logiczna, ktora przchowuje inforamcje, czy w zmiennej typu record coś jest czy nie, czy ostatnia oeraca się udała.

typ record jest typem złożónym, dostosuje się do jednej krotki z realcji dowoklnej, musimy zapewnoić, że podzpaytanie zwróci tylko jeden rekord.
można to wykorzystać podczas operowania na select. 
select *
        from zamowienia
        natural join artykuly
        natural join pudelka
        where idklienta = 7 limit 1;

create or replace function nazwa_funkcji(idklienta_ integer)
returns numeric(7,2) as
$$
declare
	r record;
begin
	select * into r
        from zamowienia
        natural join artykuly
        natural join pudelka
        where idklienta = idklienta_ limit 1;
	return r.cena;
end;
$$ language plpgsql;
select nazwa_funkcji(7);

drop function nazwa_funkcji(integer);






